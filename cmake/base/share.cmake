IF(NOT WIN32)
	STRING(ASCII 27 DP_ESC)
	SET(DP_COLOR_RESET        ${DP_ESC}[m)
	SET(DP_COLOR_BOLD         ${DP_ESC}[1m)
	SET(DP_COLOR_RED          ${DP_ESC}[31m)
	SET(DP_COLOR_GREEN     	  ${DP_ESC}[32m)
	SET(DP_COLOR_YELLOW    	  ${DP_ESC}[33m)
	SET(DP_COLOR_BLUE      	  ${DP_ESC}[34m)
	SET(DP_COLOR_MAGENTA   	  ${DP_ESC}[35m)
	SET(DP_COLOR_CYAN      	  ${DP_ESC}[36m)
	SET(DP_COLOR_WHITE     	  ${DP_ESC}[37m)
	SET(DP_COLOR_BOLD_RED  	  ${DP_ESC}[1;31m)
	SET(DP_COLOR_BOLD_GREEN	  ${DP_ESC}[1;32m)
	SET(DP_COLOR_BOLD_YELLOW  ${DP_ESC}[1;33m)
	SET(DP_COLOR_BOLD_BLUE    ${DP_ESC}[1;34m)
	SET(DP_COLOR_BOLD_MAGENTA ${DP_ESC}[1;35m)
	SET(DP_COLOR_BOLD_CYAN    ${DP_ESC}[1;36m)
	SET(DP_COLOR_BOLD_WHITE	  ${DP_ESC}[1;37m)
ENDIF()

FUNCTION(DP_Message type message)
	STRING(TOUPPER "${type}" type)
	IF("${type}" STREQUAL "ERROR")
		MESSAGE(FATAL_ERROR "${DP_COLOR_RED}[ERROR] ${message}${DP_COLOR_RESET}")
	ELSEIF("${type}" STREQUAL "WARN")
		MESSAGE("${DP_COLOR_YELLOW}[WARN ] ${message}${DP_COLOR_RESET}")
	ELSEIF("${type}" STREQUAL "INFO")
		MESSAGE("${DP_COLOR_GREEN}[INFO ] ${message}${DP_COLOR_RESET}")
	ELSEIF("${type}" STREQUAL "DEBUG")
		MESSAGE("${DP_COLOR_CYAN}[DEBUG] ${message}${DP_COLOR_RESET}")
	ELSEIF("${type}" STREQUAL "TRACE")
		MESSAGE("${DP_COLOR_WHITE}[TRACE] ${message}${DP_COLOR_RESET}")
	ELSE()
		MESSAGE(FATAL_ERROR "invalid type: ${type}")
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_CheckArgs)
	FOREACH(arg ${ARGV})
		IF(NOT DEFINED ${arg})
			DP_Message(ERROR "please set \"${arg}\"")
		ENDIF()
	ENDFOREACH()
ENDFUNCTION()

FUNCTION(DP_ReadString file var)
	FILE(STRINGS "${file}" str)
	STRING(STRIP "${str}" str)
	SET(${var} "${str}" PARENT_SCOPE)
ENDFUNCTION()

FUNCTION(DP_Any r v)
	FOREACH(arg ${ARGV})
		IF("${v}" STREQUAL "${arg}")
			SET(${r} TRUE PARENT_SCOPE)
			RETURN()
		ENDIF()
	ENDFOREACH()
	SET(${r} FALSE PARENT_SCOPE)
ENDFUNCTION()

FUNCTION(DP_SetSourceCodeFileEncodingUtf8)
	IF(MSVC)
		ADD_COMPILE_OPTIONS("/utf-8")
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_TryUseCcache)
	FIND_PROGRAM(has_ccache "ccache")
	IF(has_ccache)
		SET(CMAKE_CXX_COMPILER_LAUNCHER "ccache" PARENT_SCOPE)
		DP_Message(INFO "find ccache")
	ELSE()
		DP_Message(INFO "not find ccache")
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_TrySetCStandard std)
	IF("${CMAKE_C_STANDARD}" STREQUAL "")
		SET(CMAKE_C_STANDARD "${std}" PARENT_SCOPE)
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_TrySetCxxStandard std)
	IF("${CMAKE_CXX_STANDARD}" STREQUAL "")
		SET(CMAKE_CXX_STANDARD "${std}" PARENT_SCOPE)
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_TrySetIpo target)
	INCLUDE(CheckIPOSupported)
	CHECK_IPO_SUPPORTED(RESULT result OUTPUT output)
	IF(result)
		SET_TARGET_PROPERTIES(${target} PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE)
	ELSE()
		DP_Message(WARN "IPO is not supported: ${output}")
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_CallTarget func target public private)
	IF(NOT "${public}" STREQUAL "")
		CMAKE_LANGUAGE(CALL ${func} ${target} PUBLIC "${public}")
	ENDIF()

	IF(NOT "${private}" STREQUAL "")
		CMAKE_LANGUAGE(CALL ${func} ${target} PRIVATE "${private}")
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_FindPackage package_name)
	CMAKE_PARSE_ARGUMENTS(PARSE_ARGV 1 A "REQUIRED;QUIET" "" "")

	DPM_SetIfElse(A_REQUIRED _dp_required "REQUIRED" "")
	DPM_SetIfElse(A_QUIET _dp_quiet "QUIET" "")
	SET(${package_name}_FIND_REQUIRED FALSE)
	SET(${package_name}_FIND_QUIETLY FALSE)

	IF(EXISTS "${CMAKE_CURRENT_FUNCTION_LIST_DIR}/Find${package_name}.cmake")
		SET(cmake_module_path_save "${CMAKE_MODULE_PATH}")
		SET(CMAKE_MODULE_PATH "${CMAKE_CURRENT_FUNCTION_LIST_DIR}")
		FIND_PACKAGE("${package_name}" MODULE ${_dp_required} ${_dp_quiet})
		SET(CMAKE_MODULE_PATH "${cmake_module_path_save}")

		IF(${package_name}_FOUND)
			RETURN()
		ENDIF()
	ELSE()
		FIND_PACKAGE("${package_name}" MODULE ${_dp_required} ${_dp_quiet})
		IF(${package_name}_FOUND)
			DP_Message(INFO "find ${package_name} ok, method [default find package module mode]")
			RETURN()
		ELSE()
			DP_Message(WARN "find ${package_name} failed, method [default find package module mode]")
		ENDIF()

		FIND_PACKAGE("${package_name}" CONFIG ${_dp_required} ${_dp_quiet})
		IF(${package_name}_FOUND)
			DP_Message(INFO "find ${package_name} ok, method [default find package config mode]")
			RETURN()
		ELSE()
			DP_Message(WARN "find ${package_name} failed, method [default find package config mode]")
		ENDIF()

		IF(A_REQUIRED)
			DP_Message(ERROR "find ${package_name} failed")
		ELSE()
			DP_Message(WARN "find ${package_name} failed")
		ENDIF()
	ENDIF()
ENDFUNCTION()

FUNCTION(DP_PkgCheckModules search_path)
	SET(old_pkg_config_path $ENV{PKG_CONFIG_PATH})
	SET(old_pkg_config_libdir $ENV{PKG_CONFIG_LIBDIR})
	SET(paths)
	FOREACH(path IN LISTS search_path)
		IF(("${CMAKE_FIND_ROOT_PATH_MODE_INCLUDE}" STREQUAL "") OR ("${CMAKE_FIND_ROOT_PATH_MODE_INCLUDE}" STREQUAL "BOTH") OR ("${CMAKE_FIND_ROOT_PATH_MODE_INCLUDE}" STREQUAL "NEVER"))
			LIST(APPEND paths "${path}")
		ENDIF()
		IF(("${CMAKE_FIND_ROOT_PATH_MODE_INCLUDE}" STREQUAL "BOTH") OR ("${CMAKE_FIND_ROOT_PATH_MODE_INCLUDE}" STREQUAL "ONLY"))
			SET(is_prefix FALSE)
			FOREACH(root_dir ${CMAKE_FIND_ROOT_PATH})
				LIST(APPEND paths "${root_dir}/${path}")
				IF(NOT is_prefix)
					CMAKE_PATH(IS_PREFIX root_dir "${path}" NORMALIZE is_prefix)
				ENDIF()
			ENDFOREACH()
			IF(is_prefix)
				LIST(APPEND paths "${path}")
			ENDIF()
		ENDIF()
	ENDFOREACH()
	STRING(JOIN ":" paths ${paths})
	SET(ENV{PKG_CONFIG_PATH} "${paths}")
	SET(ENV{PKG_CONFIG_LIBDIR} "${paths}")

	PKG_CHECK_MODULES(${ARGN})

	SET(ENV{${PKG_CONFIG_PATH} "${old_pkg_config_path}")
	SET(ENV{${PKG_CONFIG_LIBDIR} "${old_pkg_config_libdir}")
ENDFUNCTION()

FUNCTION(DP_InstallFiles src_dir dst_dir files)
	FOREACH(file ${files})
		GET_FILENAME_COMPONENT(dir "${file}" DIRECTORY)
		INSTALL(FILES "${src_dir}/${file}" DESTINATION "${dst_dir}/${dir}")
	ENDFOREACH()
ENDFUNCTION()

FUNCTION(DP_SubdirList result_var dir)
	FILE(GLOB_RECURSE children LIST_DIRECTORIES true RELATIVE ${dir} ${dir}/*)
	SET(dir_list)
	FOREACH(child ${children})
		IF(IS_DIRECTORY ${dir}/${child})
			LIST(APPEND dir_list ${child})
		ENDIF()
	ENDFOREACH()
	SET(${result_var} ${dir_list} PARENT_SCOPE)
ENDFUNCTION()

FUNCTION(DP_ParseVersion version major_var minor_var patch_var tweak_var count_var)
	SET(${major_var} "0" PARENT_SCOPE)
	SET(${minor_var} "0" PARENT_SCOPE)
	SET(${patch_var} "0" PARENT_SCOPE)
	SET(${tweak_var} "0" PARENT_SCOPE)

	STRING(REPLACE "." ";" version "${version}")
	LIST(LENGTH version count)
	IF(count GREATER 0)
		LIST(GET version 0 v)
		SET(${major_var} "${v}" PARENT_SCOPE)
	ENDIF()
	IF(count GREATER 1)
		LIST(GET version 1 v)
		SET(${minor_var} "${v}" PARENT_SCOPE)
	ENDIF()
	IF(count GREATER 2)
		LIST(GET version 2 v)
		SET(${patch_var} "${v}" PARENT_SCOPE)
	ENDIF()
	IF(count GREATER 3)
		LIST(GET version 3 v)
		SET(${tweak_var} "${v}" PARENT_SCOPE)
		SET(count "4")
	ENDIF()
	SET(${count_var} "${count}" PARENT_SCOPE)
ENDFUNCTION()

MACRO(DPM_SetIfElse check_var var if_value else_value)
	IF(${check_var})
		SET(${var} "${if_value}")
	ELSE()
		SET(${var} "${else_value}")
	ENDIF()
ENDMACRO()

MACRO(DPM_ExportPkgConfigVariables prefix package_name)
	SET(${prefix}_FOUND "${${package_name}_FOUND}" PARENT_SCOPE)
	DP_ExportVersionVariables("${prefix}" "${${package_name}_VERSION}")
	SET(${prefix}_INCLUDE_DIRS "${${package_name}_INCLUDE_DIRS}" PARENT_SCOPE)
	SET(${prefix}_LIBRARY_DIRS "${${package_name}_LIBRARY_DIRS}" PARENT_SCOPE)
	SET(${prefix}_LIBRARIES "${${package_name}_LIBRARIES}" PARENT_SCOPE)
ENDMACRO()

# ---------------------------------------------------------------------------------------------------
# used for find modules in the directory where this file is located

MACRO(DPM_FM_Init)
	IF(${CMAKE_FIND_PACKAGE_NAME}_FOUND)
		RETURN()
	ENDIF()

	SET(_dp_package_name "${CMAKE_FIND_PACKAGE_NAME}")

	SET(_dp_export_variables)

	DPM_SetIfElse(${_dp_package_name}_FIND_REQUIRED _dp_required "REQUIRED" "")
	SET(${_dp_package_name}_FIND_REQUIRED FALSE)

	DPM_SetIfElse(${_dp_package_name}_FIND_QUIETLY _dp_quiet "QUIET" "")

	SET(${package_name}_FOUND FALSE PARENT_SCOPE)
ENDMACRO()

MACRO(DPM_FM_AddExportVariables)
	LIST(APPEND _dp_export_variables ${ARGN})
ENDMACRO()

MACRO(DPM_FM_AddFindPackageConfigModeExportVariables)
	LIST(APPEND _dp_export_variables
		"${_dp_package_name}_FOUND"
		"${_dp_package_name}_CONFIG"
		"${_dp_package_name}_VERSION"
		"${_dp_package_name}_VERSION_MAJOR"
		"${_dp_package_name}_VERSION_MINOR"
		"${_dp_package_name}_VERSION_PATCH"
		"${_dp_package_name}_VERSION_TWEAK"
		"${_dp_package_name}_VERSION_COUNT")
ENDMACRO()

MACRO(DPM_FM_TryFindFinal method)
	IF(${_dp_package_name}_FOUND)
		DP_Message(INFO "find ${_dp_package_name} ok, method [${method}]")
		FOREACH(var IN LISTS _dp_export_variables)
			IF(NOT DEFINED ${var})
				CONTINUE()
			ENDIF()
			DP_Message(INFO "    ${var}: ${${var}}")
			SET(${var} "${${var}}" PARENT_SCOPE)
		ENDFOREACH()
		RETURN()
	ELSE()
		DP_Message(WARN "find ${_dp_package_name} failed, method [${method}]")
	ENDIF()
ENDMACRO()

MACRO(DPM_FM_TryFindPackageCmakeBuiltInModule)
	SET(CMAKE_MODULE_PATH)
	FIND_PACKAGE("${_dp_package_name}" MODULE ${_dp_quiet})
	DPM_FM_TryFindFinal("cmake built-in module")
ENDMACRO()

MACRO(DPM_FM_TryFindPackageConfigMode)
	FIND_PACKAGE("${_dp_package_name}" CONFIG PATHS "${${_dp_package_name}_root}" NO_DEFAULT_PATH ${_dp_quiet})
	DPM_FM_TryFindFinal("find package config mode")
ENDMACRO()

MACRO(DPM_FM_TryFindPackageConfigModeDefault)
	FIND_PACKAGE("${_dp_package_name}" CONFIG ${_dp_quiet})
	DPM_FM_TryFindFinal("find package config mode, default")
ENDMACRO()

MACRO(DPM_FM_FindPackageEventuallyFailed)
	IF("${_dp_required}" STREQUAL "REQUIRED")
		DP_Message(ERROR "find ${_dp_package_name} eventually failed !!!")
	ELSE()
		DP_Message(WARN "find ${_dp_package_name} eventually failed !!!")
	ENDIF()
ENDMACRO()

# ---------------------------------------------------------------------------------------------------
