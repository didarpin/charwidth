/*
	Copyright (c) 2025 didarpin
	SPDX-License-Identifier: MIT
*/

#pragma once

static _CW_Node const _cw_{{ version | VersionV }}_kWidth1[{{ width_1 | length }}] = {
	{% for n in width_1 %}
	{{ "{" }}{{ "0x%x" | format(n[0]) }}, {{ "0x%x" | format(n[1]) }}{{ "}" }},
	{% endfor %}
};

static _CW_Node const _cw_{{ version | VersionV }}_kWidth2[{{ width_2 | length }}] = {
	{% for n in width_2 %}
	{{ "{" }}{{ "0x%x" | format(n[0]) }}, {{ "0x%x" | format(n[1]) }}{{ "}" }},
	{% endfor %}
};

static _CW_Node const _cw_{{ version | VersionV }}_kWidthAmbiguous[{{ width_ambiguous | length }}] = {
	{% for n in width_ambiguous %}
	{{ "{" }}{{ "0x%x" | format(n[0]) }}, {{ "0x%x" | format(n[1]) }}{{ "}" }},
	{% endfor %}
};

static int _cw_{{ version | VersionV }}_ambiguous_width = 1;

static inline bool _CW_{{ version | VersionV }}_IsInRanges(_CW_Node const* ranges, size_t size, cw_u32 c) {
	size_t low = 0;
	size_t high = size;
	size_t mid;
	if (c < ranges[0].low) return false;
	if (c > ranges[size - 1].high) return false;
	while (1) {
		mid = ((high - low) / 2) + low;
		if ((c >= ranges[mid].low) && (c <= ranges[mid].high)) return true;
		if (mid == low) return false;
		if (c < ranges[mid].low) high = mid;
		else low = mid;
	}
	return false;
}

static inline void _CW_{{ version | VersionV }}_TreatAmbiguousAsWide() {
	_cw_{{ version | VersionV }}_ambiguous_width = 2;
}

static inline void _CW_{{ version | VersionV }}_TreatAmbiguousAsNarrow() {
	_cw_{{ version | VersionV }}_ambiguous_width = 1;
}

static inline int _CW_{{ version | VersionV }}_CharWidth(cw_u32 c) {
	if (_CW_{{ version | VersionV }}_IsInRanges(_cw_{{ version | VersionV }}_kWidth1, {{ width_1 | length }}, c)) return 1;
	if (_CW_{{ version | VersionV }}_IsInRanges(_cw_{{ version | VersionV }}_kWidth2, {{ width_2 | length }}, c)) return 2;
	if (_CW_{{ version | VersionV }}_IsInRanges(_cw_{{ version | VersionV }}_kWidthAmbiguous, {{ width_ambiguous | length }}, c)) return _cw_{{ version | VersionV }}_ambiguous_width;
	return (c <= 0x10ffff) ? 0 : -1;
}
