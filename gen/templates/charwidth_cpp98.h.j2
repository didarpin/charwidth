/*
	Copyright (c) 2025 didarpin
	SPDX-License-Identifier: MIT
*/

#pragma once

#include <algorithm>

#include "def.h"

namespace charwidth {

enum Version {
	V_None = 0,
{% for version in versions %}
	V_{{ version | VersionV }} = {{ version | VersionI }},
{% endfor %}
};

typedef unsigned int u32;

}

namespace charwidth {
namespace details {

void EnsureIntSize4(void) {
	static char var[sizeof(int) == 4 ? 1 : -1];
	(void)var;
}

struct Node {
	u32 low;
	u32 high;
};

class G {
public:
	static Version version;
};

Version G::version = V_None;

}
}
{% for version in versions %}

#if CW_ENABLE_{{ version | VersionV }} == 1
#include "{{ version }}/cpp98.h"
#endif
{% endfor %}

namespace charwidth {

inline void SetVersion(Version version) {
	details::G::version = version;
}

inline void TreatAmbiguousAsWide() {
{% for version in versions %}
#if CW_ENABLE_{{ version | VersionV }} == 1
	v_{{ version | VersionV }}::TreatAmbiguousAsWide();
#endif
{% endfor %}
}

inline void TreatAmbiguousAsNarrow() {
{% for version in versions %}
#if CW_ENABLE_{{ version | VersionV }} == 1
	v_{{ version | VersionV }}::TreatAmbiguousAsNarrow();
#endif
{% endfor %}
}

inline int CharWidth(u32 c) {
	switch (details::G::version) {
{% for version in versions %}
#if CW_ENABLE_{{ version | VersionV }} == 1
	case V_{{ version | VersionV }}: return v_{{ version | VersionV }}::CharWidth(c);
#endif
{% endfor %}
	default: return -1;
	}
}

}
