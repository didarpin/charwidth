/*
	Copyright (c) 2025 didarpin
	SPDX-License-Identifier: MIT
*/

#pragma once

namespace charwidth {
namespace v_{{ version | VersionV }} {

typedef details::Node Node;

class G {
public:
	static const Node kWidth1[{{ width_1 | length }}];
	static const Node kWidth2[{{ width_2 | length }}];
	static const Node kWidthAmbiguous[{{ width_ambiguous | length }}];
	static int ambiguous_width;
};

const Node G::kWidth1[{{ width_1 | length }}] = {
	{% for n in width_1 %}
	{{ "{" }}{{ "0x%x" | format(n[0]) }}, {{ "0x%x" | format(n[1]) }}{{ "}" }},
	{% endfor %}
};

const Node G::kWidth2[{{ width_2 | length }}] = {
	{% for n in width_2 %}
	{{ "{" }}{{ "0x%x" | format(n[0]) }}, {{ "0x%x" | format(n[1]) }}{{ "}" }},
	{% endfor %}
};

const Node G::kWidthAmbiguous[{{ width_ambiguous | length }}] = {
	{% for n in width_ambiguous %}
	{{ "{" }}{{ "0x%x" | format(n[0]) }}, {{ "0x%x" | format(n[1]) }}{{ "}" }},
	{% endfor %}
};

int G::ambiguous_width = 1;

inline bool Compare(Node const& v, u32 c) {
	return v.high < c;
}

inline bool IsInRanges(Node const* ranges, size_t size, u32 c) {
	Node const* iter = std::lower_bound(ranges, ranges + size, c, Compare);
	return (iter != (ranges + size)) && (c >= iter->low);
}

inline void TreatAmbiguousAsWide() {
	G::ambiguous_width = 2;
}

inline void TreatAmbiguousAsNarrow() {
	G::ambiguous_width = 1;
}

inline int CharWidth(u32 c) {
	if (IsInRanges(G::kWidth1, {{ width_1 | length }}, c)) return 1;
	if (IsInRanges(G::kWidth2, {{ width_2 | length }}, c)) return 2;
	if (IsInRanges(G::kWidthAmbiguous, {{ width_ambiguous | length }}, c)) return G::ambiguous_width;
	return (c <= 0x10ffff) ? 0 : -1;
}

}
}
